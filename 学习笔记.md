lower_bound()：在有序集合中查找第一个大于等于val的元素
upper_bound()：在有序集合中查找第一个大于val的元素

n & n - 1:将n的二进制最右边的1变为0
n & -n:将n的二进制最右边的1提取出来

select:
	优点：1）遵循POSIX标准，可以跨平台，监控的超时时间可以精确到微秒

	缺点：1）所有监控的文件描述符是有上限的，默认是1024，取决于FD_SETSIZE的大小
		 2）select实现的监控原理是在内核中轮询遍历状态，因此会随着描述符增多性能下降
		 3）select每次监控的时候都会修改监控集合中的值，都需要重新向内核拷贝监控描述符集合
		 4）select要监控的集合中的描述符每次都要向内核拷贝数据
poll:
	优点：1）采用事件结构的方式对描述符进行监控，简化了多个事件集合的监控方式
		 2）没有描述符的具体上限

	缺点：1）不能跨平台
		 2）随着描述符增多性能下降
epoll:
	优点：1）epoll没有监控文件描述符数量的上限
	  	 2）采用事件结构简化了select监控集合的监控流程
		 3）epoll是一个异步阻塞操作，发起调用，让操作系统进行文件描述符的监控，使用事件回调函数对描述符进行监控，避免了select的遍历轮询，性能不会随着文件描述符增多而下降
		 4）epoll发起调用进行等待，循环判断内核中epoll就绪事件链表是不是为空来确定是否有就绪事件，若有就绪事件，则将对应的事件拷贝到用户态，直接告诉了用户那些描述符就绪了，不需要循环判断。
		 5）epoll描述符的事件结构，只需要向内核中拷贝一次，不需要每次都拷贝

	缺点：1）不能跨平台
		 2）延时时间只能精确到毫秒

跨域：指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的
	同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域
	在同一域名下，不同页面之间可以共享 Cookie；而在不同域名下，默认情况下是不能共享 Cookie 的

CSRF:跨站请求伪造，攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作（如转账和购买商品））。因为浏览器之前认证过，所以被访问的站点会觉得这是真正的用户操作而去运行

XSS：跨站脚本攻击，通过将恶意的JavaScript代码注入到Web页面中，当用户浏览该页之时，嵌入其中Web里面的JavaScript代码会被执行，从而达到恶意攻击用户的目的

![](https://img-blog.csdnimg.cn/720571a19a264f33bdf387d9d43a73da.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zu254K55pWy5Luj56CB,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

1、客户端通过账户密码登录访问网站A。
2、网站A验证客户端的账号密码，成功则生成一个sessionlD，并返回给客户端存储在浏览器中。
3、该客户端Tab—个新页面访问了网站B。
4、网站B自动触发要求该客户端访问网站A。(即在网站B中有链接指向网站A)
5、客户端通过网站B中的链接访问网站A。(此时携带有合法的SessionID进行访问站A的)
6、此时网站A只需检验sessionIlD是否合法，合法则执行相应的操作。(因此具体啥工具就得看链接，以及网站B要求访问时携带的数据)

所以要被CSRF攻击，必须同时满足两个条件：
									登录受信任网站A，并在本地生成Cookie。
									在不登出A的情况下，访问危险网站B

get:向服务器获取数据、请求参数在URL中、请求参数大小有限制、只支持ASCII编码、安全性较低、允许被浏览器缓存（可以携带body，但不建议）
post:向服务器发送数据进行更新或创建、请求参数在body中、请求参数无大小限制、无编码限制、安全性相对较高、不允许被浏览器缓存

TCP快重传定为收到三次重复的ACK确认报文原因：发送发收到ACK，此时可能是包乱序或者丢包，所以在收到前两次ACK时先不重传，等到收到3次ACK后有很大可能丢包，此时再重传

Linux-Top命令：显示系统资源使用情况（包括CPU使用率、内存使用率、进程信息，监控的最小单位为进程，监控更小单位用ps或netstat），Virtual:进程使用的虚拟内存大小  RES：进程使用的、未被换出的内存大小 SHR:共享内存

Linux-df-h命令：查看磁盘使用情况（disk free)

cat filename:查看文本文件内容

head/tail -n 10 filename：显示文件前/后10行内容

ps:查看进程信息

netstat [选项]：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。

虚拟内存：通过分页或者分段建立虚拟内存和物理内存的对应关系
	好处：（1）：有助于进程内存管理，进程认为自己获取的内存是连续的，编写程序时无需分配大块内存，页表可以实现内存的权限控制
	      (2)：更易实现内存和数据共享，只需将各个进程的虚拟地址指向共享的物理内存即可
		  (3)：通过SWAP可以在物理内存不够用时，将暂时不用的内存数据放到磁盘中腾出内存空间，等需要使用时再从磁盘加载回内存
直接用物理内存问题：（1）:程序存储空间未隔离（2）：程序释放内存后会造成内存碎片（3）：内存空间较小

git reset:删除错误的提交记录，回退到正常版本
git revert:创建新的提交记录，覆盖错误版本，但错误版本提交记录还在

git merge:将分支最新提交和主线最新提交合并生成一个新的提交，适用于上游分支合并下游分支内容
![](https://img-blog.csdnimg.cn/img_convert/b96eb877e38c4ab55242b7068cd8a8c6.png)

git rebase:将分支的起始历史放到主线的最后一次提交上，适用于下游分支更新上游分支内容
![](https://img-blog.csdnimg.cn/img_convert/dcf29efa49290c5ad42cf7bd9c8f09a3.png)

UDP实现TCP：
	       1、添加seq/ack机制，确保数据发送到对端
           2、添加发送和接收缓冲区，主要是用户超时重传。
           3、添加超时重传机制。

（a+b)%mod = (a % mod + b % mod)% mod;
(a * b ) % mod = (a % mod * b % mod) % mod;

Dos(denial of service)拒绝服务攻击：用数据包淹没本地系统，以打扰或严重阻止捆绑本地的服务响应外来合法的请求，使系统过于忙碌而不能执行有用的业务并且占尽关键系统资源，甚至使本地系统崩溃
	TCP SYN泛洪(SYN Flood)：
	ping泛洪(ping-Flood)
	UDP泛洪(UDP-Flood)
	分片炸弹(fragmentation bombs)
	缓冲区溢出(buffer overflow)
	ICMP路由重定向炸弹(ICMP routeing redirect bomb)

vector扩容机制：
	（1）申请新内存->数据拷贝到新内存->释放旧内存
	（1）vector扩容成倍增长可以使push_back操作的均摊时间复杂度达到O(1)，而如果每次固定长度扩容会使其均摊时间复杂度为O(n)
	（2）windows系统中扩容是1.5倍，因为Windows中堆管理系统会对释放的堆块进行合并,这样多次扩容之后,就可以使用之前已经释放的空间
	（3）Linux系统中扩容为2倍，与其内存管理系统有关，其内存空间分区链均对应2的整次幂倍大小，可以快速找到对应内存块

内存泄露检测方法：
	（1）mtrace:是 GNU Glibc 自带的内存问题检测工具，它可以用来协助定位内存泄露问题。它的实现源码在glibc源码的malloc目录下，其基本设计原理为设计一个函数 void mtrace ()，函数对 libc 库中的 malloc/free 等函数的调用进行追踪，由此来检测内存是否存在泄漏的情况，通过在编译时加入-g，并且设置日志输出目录，可以在日志中检查内存泄露情况
	（2）Valgrind工具，其中的Memcheck用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，一切对malloc() / free() / new / delete 的调用都会被捕获

MySQL一张数据表对应三个文件，.frm文件存放表结构，.MYD文件存放表数据,.MYI存放表索引

	分区：就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的，MySQL支持范围分区（RANGE），列表分区（LIST），哈希分区（HASH）以及KEY分区

	分表：将一个表中的数据按照某种规则分拆到多张表中，降低锁粒度以及索引树，提升数据查询效率
		水平分表：按照表中的数据记录进行拆分
		垂直分表：按表的字段进行拆分，尽量将使用频率高字段放到一张表里，剩下使用频繁低的字段放到另一张表里

	分库：将一个数据库中的数据按照某种规则分拆到多个数据库中，以缓解单服务器的压力

分库分表带来问题：
				（1）引入分布式事务问题
				 (2)主键(自增ID)唯一性问题,在数据库表设计时，经常会使用自增ID作为数据主键，这就导致后续在迁库迁表、或者分库分表操作时，会因为主键的变化或者主键不唯一产生冲突
				 (3)跨库多表join问题
				 (4)跨库聚合查询问题,分库分表会导致常规聚合查询操作，如group by，order by等变的异常复杂

当hash表的负载因子等于1时需要进行rehash，开辟一个原来桶空间两倍大小的新桶空间，然后将原来桶的数据全部重新hash到新桶中

**BIO**：同步并阻塞，服务实现模式为一个连接对应一个线程，即客户端发送一个连接，服务端要有一个线程来处理。如果连接多了，线程数量不够，会发生阻塞，一个连接一个线程，用于连接数目比较小且固定的架构

**NIO**：同步非阻塞，服务实现模式是一个线程可以处理多个连接，即客户端发送的连接都会注册到多路复用器上，然后进行轮询连接，有I/O请求就处理，一个请求一个线程，适用于连接数目多且连接比较短（轻操作）的架构

**AIO**：异步非阻塞，基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当，一个有效请求一个线程，适用于连接数目多且连接比较长（重操作）的架构

**同步**：用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行

**异步**：用户线程发起I/O请求后仍需要继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数

**阻塞**：指I/O操作需要彻底完成后才能返回用户空间

**非阻塞**：指I/O操作被调用后立即返回一个状态值，无需等I/O操作彻底完成


HTTP报文分为请求报文（浏览器端向服务器发送）和响应报文（服务器处理后返回给浏览器端）两种，每种报文必须按照特有格式生成，才能被浏览器端识别。

**请求报文**：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

	请求行：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。

![](https://img-blog.csdnimg.cn/cf93deb437fa4c668386976fe7834596.png)
	
	请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。

	空行：请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行，最后一个请求头之后是一个空行，发送回车符和换行符\r\n，通知服务器以下不再有请求头

	请求体：可以添加任意的其他数据。

![](https://img-blog.csdnimg.cn/eca868531755423fbf2cb1d65f37ebd3.png)

**响应报文**：状态行+消息报头+空行+响应正文四个部分组成

	状态行：由HTTP协议版本号，状态码，状态码说明三部分组成。

![](https://img-blog.csdnimg.cn/9e28760d5737489d9f45d70cad6788dd.png)
![](https://img-blog.csdnimg.cn/dfc8367f816340a1b95b42d9e7c1f27c.png)
![](https://img-blog.csdnimg.cn/f63450ecdbe94bf087abd713d45a514d.png)
![](https://img-blog.csdn.net/20170326231431389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

	响应头：用来说明客户端要使用的一些附加信息。

	空行：消息报头后面的空行是必须的。

	响应体：服务器返回给客户端的文本信息等。


断点续传：在请求报文header字段增加Range字段表示发送数据的范围，在响应报文header字段增加content-range字段表示已接收数据范围和整个文件大小


Linux进程状态：
				（1）运行态：操作系统会为CPU创建一个进程队列，进程处于运行状态并不意味着该进程此时一定正在被运行，只要该进程处于CPU的运行队列中即可
				 （2）阻塞态：进程在等待除了CPU之外的其他资源就绪
				 （3）挂起态：由于内存空间不足，操作系统将在等待资源的进程对应的代码数据放到磁盘中以节省内存空间，挂起状态不会移动进程的PCB，只会移动进程对应的代码和数据。

孤儿进程：父进程结束了子进程还未结束，孤儿进程会被init进程（pid为1)收养

僵尸进程：子进程结束，但父进程未回收相关资源，占用内存空间

"\n"：内容为一个回车符发子覅穿，表示换行的转义字符

endl：换行，并且会刷新缓冲区，对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于cout来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用endl代替'\n'一般是个好习惯，对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用'\n',过多的endl是影响程序执行效率低下的因素之一


线程池线程数目：

			（1）CPU密集型，数目 = CPU + 1
			（2）IO密集型，数目 = CPU * 2
			（3）混合型，数目 = （（线程平均等待时间 + 线程平均CPU时间）/ 线程平均CPU时间）* CPU

CPU密集型：单核CPU情况下不适合多线程，因为主要是CPU操作，单线程和多线程耗时基本一样，但多线程可能有线程切换的开销；多核CPU适合多线程
IO密集型：单核和多核CPU都适合多线程，可以充分利用CPU


在Linux中的文件系统会给每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们都主要是被用来记录文件的元信息和目录层次结构
	文件=目录项+inode+数据块（block）

索引节点：inode，用来记录文件的元信息，比如inode编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等。索引节点是文件的唯一标识，它们之间一一对应，也同样都是被存储在硬盘当中，索引节点也是会占用磁盘的存储空间的。

目录项：dentry，用来记录文件的名字，索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但是它与索引节点不相同的是，目录项是由内核维护的一个数据结构，不是存放咋磁盘中，而是缓存在内存里面。目录项包括文件名和inode节点号。

inode映射表：inode bitmap：位图：记录着哪些inode使用了，哪些没有使用。

block映射表：block bitmap：记录着哪些block使用了，哪些没有使用。

其中，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存着的是文件数据，而目录文件在磁盘里面保存子目录或者文件。

1、目录和目录项分别指的是什么？

目录是一个文件，它是被持久化的存储在磁盘里面，而目录项是内核中的一个数据结构，缓存在内存里面。

如果查询目录就会频繁的从磁盘读取，效率会很低，所以内核就会把已经读过的目录用目录项这个数据结构先缓存在内存里面，等到下次读取到相同的目录的时候，就只需要从内存里面去读取，这样就大大提升了文件系统的效率。

2、文件数据是如何存储在磁盘空间的？

磁盘读写的最小单位是扇区，扇区的大小只有512B的大小，如何每次读写的时候都是这么小的单位，会导致读写的效率非常低。

所以，文件系统就把多个扇区组成了一个逻辑块，每次读写的最下单位就是逻辑块（数据块），Linux中的逻辑块的每个块的大小为4KB，也就是一次性可以读取8个扇区，这将会大大提高了磁盘的读写效率。

3、文件系统如何读取到文件：
	1、根据文件名通过目录项知道它的inode号。（stat + 文件: 查看具体文件的inode信息）
	2、通过inode号找到inode table里的inode（位置）
	3、通过inode里的block指针，找到对应的数据块


4、删除一个文件删除了哪些东西，为什么数据可以恢复？

删除了目录项，把inode映射表里使用的inode标志为未使用，把block映射表里的block标志为未使用。inode没有删除；block没有删除。删除文件时没有删除数据，只是将其覆盖
删除文件之后，要马上停止新建文件操作，最好是关机，使用恢复软件去恢复，文件系统里有日志--会去记录磁盘的相关操作，可以找回目录项等信息。

5、删除一个小文件2k快，还是删除一个大文件2T快，还是一样的快？

删除小文件快，因为小文件和大文件里都含有一个inode和目录项，然后会有很多个block，要将inode位图和block位图里对应的项标记为未使用，大文件里包含的block多，更耗时

6、inode的数量比例和block数量比例不一致 ，一般inode的数量会少一点。如果你的系统里面小文件过多，会造成你的inode耗尽 你的block明明还有磁盘空间 但是创建不了文件了



RAII:Resource Acquisition Is Initialization，资源获取即初始化，对象初始化时自动调用构造函数，对象到达其作用域结尾时，自动调用析构函数，利用对象的生命周期来控制资源

shared_ptr:
			(1)引用计数进行自增、自减操作是线程安全的，因为是atomic原子类型，保证自增自减操作是原子操作 atomic<int>* use_count;
		 	（2）多线程读同一个shared_ptr是线程安全的
			（3）多线程写同一个shared_ptr则不安全，需要加锁,因为shared_ptr内部有ptr指针和计数指针，拷贝或赋值时先拷贝ptr指针，再拷贝计数指针，这两步操作不是原子的

![](https://img-blog.csdnimg.cn/75cb5080cf544f92a69ec1292f7cbb1e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bm05bm05bm05bm05bm0,size_20,color_FFFFFF,t_70,g_se,x_16)


explicit关键字修饰类的构造函数时，禁止构造函数的隐式类型转换，无法使用不是同一类型的数据进行赋值或者初始化，比如class s = {1，2}，禁止将int类型数据隐式转换为class类型进行初始化，所以会报错

常见序列化和反序列化协议有XML、JSON、protobuf，相比于其他protobuf更有优势：
	1、protobuf是二进制存储的，xml和json都是文本存储的。故protobuf占用带宽较低
	2、protobuf不需要存储额外的信息，json如何存储数据？键值对。例：Name:”zhang san”, pwd: “12345”，protobuf存储数据的方式：“zhang san” “123456”（无额外信息）
	3、protobuf跨平台语言支持，可以直接在同构和异构系统中进行调用。异构系统指的是有的RPC进程是C++写的服务，有的RPC进程是Golang 或者Java 写的服务，但因为都是基于统一的protobuf 协议进行通信的，所以直接可以进行远程RPC通信。
	4、protobuf序列化和反序列化效率高速度快且序列化后体积比XML和JSON都小很多，适合网络传输。

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mOTk3NjczYi05ODRmLTQyOTYtYTcxNC0zZjYxNmU4ZDc2MTcucG5n?x-oss-process=image/format,png)

迭代器：迭代器对象通常会存储与特定容器实例相关的信息，如指向容器中的某个元素的指针或者其他表示当前位置的数据。通过这些信息，迭代器对象可以在容器中定位和访问元素。虽然迭代器对象本身是独立的，但它与特定容器实例密切相关，因为它需要知道容器的内部结构以执行遍历和访问操作。当你使用容器的成员函数（如 begin()、end() 等）获取迭代器时，这些函数会创建一个与容器实例关联的迭代器对象。这个迭代器对象存储了足够的信息，以便在容器内遍历元素。

1.deque(双端队列)：是一种双开口的“连续”空间的数据结构，双开口的含义是：在头尾两端都可以进行插入和删除操作，且时间复杂度为O(1)。需要注意的是deque并不是真正连续的空间，不是像vector那样底层是连续空间的数组，而是由一段段连续的小空间拼接而成的，实际deque类似于一个动态的二维数组，为了管理分段空间，deque容器引入了map，称之为中控器，map是一块连续的空间，其中每个元素是指向缓冲区buffer的指针，缓冲区才是deque存储数据的主体
![](https://img-blog.csdnimg.cn/ff4fdf3103724f94b6d21d11ae8d5fa8.png)
                  
2.双端队列底层是一段假象的连续空间，实际上是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器上，因此deque的迭代器就比较复杂
![](https://img-blog.csdnimg.cn/cdb461e7fd8b41aaa9198260caf294e9.png)

deque的优点：
	与vector比较，deque的优势是：头部插入删除时，不需要搬移元素，效率高，而且在扩容时，也不需要搬移大量的元素。因为deque在头部插入删除的时候，是直接在前面开一块空间（缓冲区buffer）插入元素的，尾插同理，在后面开空间。
	与list比较，deque的底层是连续空间，空间利用率比较高，不需要存储额外的字段。
deque的缺点：
	不适合遍历及排序，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下，并且deque的迭代器非常复杂
	中间插入删除数据不如list
	随机访问速度不如vector

为什么选择deque作为stack和queue的底层默认容器：
		1.stack和queue不需要遍历（因此stack和queue没有迭代器），只需要在固定的一端或者两端进行操作；
		2.在stack和queue中，元素增长时，deque和vector相比，deque效率更高（扩容时不需要搬移大量数据），内存使用率更高。

map中每个节点包括：键、值、颜色位、父节点指针、左子节点指针、右子节点指针

C++结构体和类的区别：
（1）结构体是值类型，用于存储数据的值，类是引用类型，用于存储对实际数据的引用
（2）结构体赋值是直接赋值的值，而对象的赋值的是传递对象的地址
（3）结构体内默认“数据“访问权限和继承权限是public，对象内“”成员“”默认访问权限和继承权限是private（本质区别）
（4）struct也可以有成员函数、继承、实现多态

DNS（域名解析协议）：端口号53，基于TCP/UDP协议，大部分情况下使用UDP，当进行区域间传输或者DNS报文长度过长（大于512字节）时会使用TCP传递

全局变量和局部变量可以重名，函数内引用时优先使用局部变量，变量前加：：可以使用全局变量

new分配内存失败会抛出异常，new(std::nothrow)失败会返回空指针

# 将file1 和file2 合并成一个新的文件file，
# 如果file以前有内容，则先会清除它们然后再写入合并后的内容。
cat file1 file2 > file
 
# 如果不想清除文件内容，则可以把单边号>变成了双边号>>
cat file1 file2 >> file

# 显示文件最后100行
cat filename | tail -n 100
 
# 显示文件前面100行
cat filename | head -n 100
 
# 从100行开始显示，显示100行以后的所有行
cat filename | tail -n +100
 
# 显示100行到500行
cat filename | head -n 500 | tail -n +100 或者 cat filename | tail - n +100 | head -n 400

netstat -tuln：查看所有的监听端口
		-t：显示TCP连接
		-u：显示UDP连接
		-l：仅显示监听状态的连接
		-n：以数字形式显示端口号和Ip地址

telnet [远程主机地址] [端口号]    ：查看远程主机的端口号是否开放

dig 域名  :查询域名的IP地址


硬中断软中断区别：
（1）硬中断由外部设备引起，软中断是软件触发
（2）硬中断是可屏蔽的（NMI硬中断不可屏蔽），软中断不可屏蔽
（3）硬中断的中断号是由中断控制器提供的（NMI硬中断中断号系统指定为02H）；软中断的中断号由指令直接给出，无需使用中断控制器

Linux中栈大小为8M，ulimit -a查看当前栈大小，ulimit -s size，改变当前栈大小


unique_ptr作为函数参数传递：
（1）函数参数为引用类型可以直接使用unique_ptr传参
（2）函数参数为普通参数类型，需要使用move(unique_ptr)进行传参，因为unique_ptr禁止拷贝，只能通过移动传参


.和->：对象实例直接访问结构体或类成员时用"."，通过对象的指针来访问成员会使用"->"，相当于先对指针解引用以获取对象，然后使用"."访问其成员


MySQL三种删除：
（1）delete:只删除数据，不删除表结构，并且不是真正删除数据，而是将删除的数据设置为不可见，对应磁盘空间可以被覆盖,会触发事务，可回滚
（2）truncate:删除表中所有数据并释放磁盘空间，保留表的结构，不触发事务，不可回滚
（3）drop：删除表结构，并释放空间，不触发事务，不可回滚